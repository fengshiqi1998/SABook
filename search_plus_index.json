{"./":{"url":"./","title":"简介","keywords":"","body":"软件体系结构 代码实现可见链接：代码实现 什么是模式 模式是一条由三部分组成的规则。 一个特定环境、一个问题、一个解决方案。 模式的核心思想：进行设计的复用。 设计模式与体系结构模式 设计模式 描述了定制化的相互通信的对象与类， 以解决特定环境中的通用设计问题。 体系结构模式 是对系统的高层设计，是从一个较 高的层次来考虑组成系统的构件、构件之间的连接关系，以及系统需满足的约束等，用以实现体系结 构级的设计复用。通常又被成为架构模式、体系结构风格。 关系 图：SArelative © 2019 冯世祺. All rights reserved.本站访客数 人次"},"designmodel.html":{"url":"designmodel.html","title":"零、设计原则","keywords":"","body":"好设计的原则 不太好的代码的表现（设计正在“腐烂”的征兆） 过于僵硬 Rigidity 过于脆弱 Fragility 不可重用性 immobility 粘滞性过高 viscosity（修改代码时，耦合度太大） 好的系统设计应具备的三个性质 可扩展性 Extensibility 灵活性 Flexibility 可插入性 Pluggability 面向对象设计原则 单一职责原则（SingleResponsibilityPrinciple） 原则简介 类的职责要单一，不能将太多的职责放在一个类中。主要为了解耦和增强内聚性（高内聚、低耦合）。（高内聚：内部功能集中，相关度强；低耦合：类之间的关系明确） 高内聚性原则 避免相同的职责（功能）分散到不同的类中实现 避免一个类承担过多的职责 可以减少类之间的耦合 单一职责原则生活中的实例 组织机构的设置 公司人员的分工 单一职责原则示例 类的设计主要工作是“发现职责”并“分离职责” 图：DBconnect 数据库连接和数据库访问操作相互分离 遵守单一职责原则的设计模式 工厂模式 分离对象的“创建”和对象的“使用” 图：factorymodel 开闭原则（Open-ColsedPrinciple） 原则简介 软件实体对扩展是开放的，但对修改时关闭，即在不修改一个软件实体的基础上去扩展其功能。（接口：只定义其方法名称，不定义其实现） Open：模块的行为必须是开放的、支持扩展的，而不是僵化的 Closed：在对模块的功能进行扩展时，不应该影响或大规模地修改已有的程序模块 绝大部分的设计模式都符合开闭原则 抽象化是开闭原则的关键 要求开发人员可以在不修改系统中现有的代码的前提下，而实现对应用系统的软件功能的扩展。 里氏代换（替换）原则（向上转型）（Liskov Substitution Principle） 原则简介 在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象。 主要是针对继承的设计原则 子类型必须能够替换掉它们的父类型，并出现在父类能够出现的任何地方 子类可以扩展父类的功能，但不能改变父类原有的功能 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 举例 生物学的分类体系中把企鹅归属为鸟类。模仿这个体系，设计出这样的类和关系 依赖倒转原则（Dependency Inversion Principle） 原则简介 要针对抽象层编程，而不要针对具体类编程 将依赖关系倒置为 上层模块不应该依赖于下层模块，它们共同依赖于一个抽象 父类不能依赖子类，它们都要依赖抽象类 抽象不能依赖于具体，具体应该要依赖于抽象 图：dependencyprinciple 图中两个模块之间定义一个抽象接口，上层模块调用抽象接口中定义的方法，下层模块实现该接口的方法 接口隔离原则（Interface Segregation Principle） 原则简介 使用多个专门的接口来取代一个统一的接口 一个类对另外一个类的依赖性应当是建立在最小的接口上 客户端不应该依赖那些它不需要的接口（方法） 该原则指导我们如何正确地进行接口设计：谨用继承！ 过于臃肿的接口设计是对接口的污染（Interface Contamination） 一个没有经验的设计师往往想节省接口的数目，将一些功能相近或功能相关的接口合并 所谓接口污染就是为接口添加了不必要的职责 如果开发人员在接口中增加一个新的功能方法的主要目的只是为了减少接口的实现类的数目，如此设计将导致接口被不断地“污染”并“变胖”。 如何避免不良的接口设计 用多个专门的接口，而不使用单一的总接口。 一个接口就只代表一个角色 使用接口隔离原则拆分接口时，首先必须满足单一职责原则 软件系统中类的设计是否合理不在乎类本身的数目： 接口污染会给系统带来维护和重用等方面的问题。 为了能够重用被污染的接口，接口的实现类就被迫要实现并维护不必要的功能方法。 使用接口的多重继承实现对不同的接口的组合，从而对外提供组合功能——达到“按需提供服务”。 合成复用原则（Composite Reuse Principle） 原则简介 在系统中应该尽量多使用组合和聚合关联关系， 尽量少使用甚至不使用继承关系 又称为组合/聚合复用原则 尽量使用对象组合，而不是继承来达到复用目的 一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象 新对象通过委派调用已有对象的方法达到复用其已有功能的目的 继承复用：实现简单，易于扩展，没有足够的灵活性（“白箱”复用 ） 组合/聚合复用：耦合度相对较低，选择性地调用成员对象的操作；可以在运行时动态进行。（“黑箱”复用 ） 尽量使用组合/聚合关系，少用继承 迪米特法则（Law of Demeter） 原则简介 一个软件实体对其他实体的引用越少越好，或者说如果两个类不必彼此直接通信，那么这两 个类就不应当发生直接的相互作用，而是通 过引入一个第三者发生间接交互 要求一个软件实体应当尽可能少的与其他实体发生相互作用 又称为最少知识原则 不要和“陌生人”说话 只与你的直接朋友通信 每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位 创建松耦合的类 应用时注意 在类的划分上，应该创建有弱耦合的类； 在类的结构设计上，每一个类都应当尽量降低成员的访问权限； 在类的设计上，只要有可能，一个类应当设计成不变类； 在对其他类的引用上，一个对象对其它对象的引用应当降到最低； 尽量降低类的访问权限； 谨慎使用序列化功能； 不要暴露类成员，而应该提供相应的访问器(属性) 总结 单一职责原则要求在软件系统中，一个类只负责一个功能领域中的相应职责。 开闭原则要求一个软件实体应当对扩展开放，对修改关闭，即在不修改源代码的基础上扩展一个系统的行为。 里氏代换原则可以通俗表述为在软件中如果能够使用基类对象，那么一定能够使用其子类对象。 依赖倒转原则要求抽象不应该依赖于细节，细节应该依赖于抽象；要针对接口编程，不要针对实现编程。 接口隔离原则要求客户端不应该依赖那些它不需要的接口，即将一些大的接口细化成一些小的接口供客户端使用。 合成复用原则要求复用时尽量使用对象组合，而不使用继承。 迪米特法则要求一个软件实体应当尽可能少的与其他实体发生相互作用。 © 2019 冯世祺. All rights reserved.本站访客数 人次"},"chapters/singleton.html":{"url":"chapters/singleton.html","title":"一、单例模式","keywords":"","body":"单例模式 概念 确保一个类仅有一个唯一的实例，并且提供一个全局的访问点 环境及问题 环境——一个类可以创建多个对象 单例模式要解决的问题——独生子女 解决方案 首先将构造函数声明成私有类型，屏蔽通过直接实例化的形式来访问。 其次控制全局只有一个实例的类—Static。 第三，提供一个可以获得实例的方法，用于返 回类的实例，并保证得到的是同一个对象。 图：singleton 代码实现（JAVA） 图：singletoncode 单例模式的应用举例 Windows的Task Manager（任务管理器） 网站的计数器、 应用程序的日志应用 数据库连接池的设计 Web应用的配置对象的读取 操作系统的文件系统 单例模式的应用场景 资源共享的情况下，避免由于资源操作时导致的性能损耗。如上述中的日志文件，应用配置 控制资源的情况下，方便资源之间的互相通信。如数据库连接池等 © 2019 冯世祺. All rights reserved.本站访客数 人次"},"chapters/observer.html":{"url":"chapters/observer.html","title":"二、观察者模式","keywords":"","body":"观察者模式 环境 学期初上课教师做自我介绍公布联系方式 学生记录教师联系方式 教师联系方式更改时学生更新本地记录的内容 问题 背景：某对象发生变化，需其他对象做出调整。 应用程序的可维护性和重用性。 互动关系不能体现成类之间的直接调用，对象之间关系的解耦。 详解 又叫发布-订阅模式。 两个角色：观察者和被观察对象 两者之间存在“观察”的逻辑关联 当被观察者发生改变的时候，观察者就会观察到这样的变化，并且做出相应的响应 “观察”不是“直接调用” 实现观察者模式有很多形式，比较直观的一种是使用一种“注册——通知——撤销注册”的形式。 实现步骤 观察者将自己注册到被观察对象中，被观察对象将观察者存放在一个容器里 被观察对象发生了某种变化，从容器中得到所有注册过的观察者，将变化通知观察者。 观察者告诉被观察者要撤销观察，被观察者从容器中将观察者去除。 设计类图 图：observeruw 扩展说明 在.NET框架中，使用代理以及事件，可以更好的实现观察者模式。 在事件的模式下，声明事件的类就是被观察者。 IObserver和ISubject接口的方法可以减少观察者和观察对象之间的耦合，而代理和事件几乎消除了这两个模块之间的耦合。 © 2019 冯世祺. All rights reserved.本站访客数 人次"},"chapters/adapter.html":{"url":"chapters/adapter.html","title":"三、适配器模式","keywords":"","body":"适配器模式 环境 游戏中的坐骑——五彩神鹿 第一世界它的行走方式为奔跑，第二世界它的行走方式为飞！ 问题 想使用一个已经存在的类， 但他的接口不符合需求。 将一个类的接口转换成客户希望的另外一个接口 使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 适配器模式介绍 适配器模式中有以下的四种角色： 目标(target)：定义客户端使用的与特定领域相关 的接口。 被适配者(adaptee)：定义了一个已经存在的接口 ，这个接口需要匹配。 适配者(adapter)：对Adaptee的接口与target的接 口进行适配。 客户端(Client)：与符合target接口的对象协同。 模式分类 类的适配器模式（采用继承实现） 图：success 对象适配器（采用对象组合方式实现） 图：combine 适配器模式实现步骤 类适配器： 确定目标接口 确定被适配者 创建适配器（继承自被适配者，实现目标接口） 对象适配器： 确定目标接口 确定被适配者 创建适配器（拥有被适配者的对象，实现目标接口） 步骤一：被确定目标接口 图：step1 步骤二：被确定被适配者 图：step2 步骤三 创建适配器（类适配器） 创建适配器（对象适配器） 类适配器和对象适配器哪个更好 类适配器采用“多继承”的实现方式，带来了 不良的高耦合 对象适配器采用“对象组合”的方式，更符合 松耦合精神 类适配器无法面对多个被适配对象 合成复用原则 © 2019 冯世祺. All rights reserved.本站访客数 人次"},"chapters/strategy.html":{"url":"chapters/strategy.html","title":"四、策略模式","keywords":"","body":"策略模式 环境 游戏中武士可以随时更换装备 问题 将每一个一系列的算法封装起来。 而且使它们还可以相互替换。 让算法独立于使用它的客户而独立变化。 详解 strategy pattern 策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。 图：strategyalgorithm 三种角色 抽象策略类(Strategy): 定义所有支持的算法的公共接口。 具体策略类(ConcreteStrategy): 以Strategy接口实现某具体算法。 环境类(Context): 维护一个对Strategy对象的引用。可定义一个接口来让Strategy访问它的数据。 实现 步骤 定义抽象策略类 图：strategydefineinterface 实现具体策略类 图：strategyrealization1 图：strategyrealization2 定义环境类 图：strategydefinedev1 图：strategydefinedev2 © 2019 冯世祺. All rights reserved.本站访客数 人次"},"chapters/composite.html":{"url":"chapters/composite.html","title":"五、组合模式","keywords":"","body":"组合模式 问题 用户想表示对象的部分-整体层次结构。 并希望忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象。 描述了如何将容器对象和叶子对象进行递归组合，使得用户在使用时无须对它们进行区分，可以一致地对待容器对象和叶子对象。 详解 组合模式 又叫做“整体-部分模式”。 它使树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素,从而使得客户程序与复杂元素的内部结构解耦。 图：compositedetail 三种角色 抽象组件类(Component)：组合中的对象声明接口，实现所有类共有接口的行为。声明用于访问和管理Component的子部件的接口。 叶子节点(Leaf)：叶节点对象，叶节点没有子节点。由于叶节点不能增加分支和树叶，所以叶节点的Add和Remove没有实际意义。 组件集合类(Composite)：实现Componet的相关操作，比如Add和Remove操作。其中包含Component 的容器，用来存储叶节点集合，有叶节点行为，用来存储叶节点集合。 实现步骤 一、定义抽象组件接口 图：compositestep1 二、实现叶子节点类，实现抽象组件类的接口 图：compositestep2 三、实现组件集合类，实现抽象组件类的接口 图：compositestep3 四、定义环境类，将叶子节点和组件集合加入根组件集合 图：compositestep4 © 2019 冯世祺. All rights reserved.本站访客数 人次"},"chapters/decorator.html":{"url":"chapters/decorator.html","title":"六、装饰模式","keywords":"","body":"装饰模式 环境 汽车4s店汽车销售 出售奥迪A1，A4，A6； 可装饰的组件倒车雷达，真皮座椅，gps定位 用户可以挑选汽车的型号，加任意的组件 问题 不必改变原类文件和使用继承的情况下，动态的扩展一个对象的的功能。 应用程序的可维护性，可扩展性差。 详解 装饰模式 装饰模式中的角色：油漆工(decorator)是用来刷油漆的；被修饰者(decoratee)是被刷油漆的对象。 动态给一个对象添加一些额外的功能和职责，就象在墙上刷油漆。 实现装饰模式有很多形式，最常见的一种就是“实现被装饰者类---定义被装饰者对象----使用被装饰者对象产生装饰者对象”。 设计类图 图：decoratorclass 实现 首先定义被装饰者类 通过被装饰者对象产生装饰者对象 © 2019 冯世祺. All rights reserved.本站访客数 人次"},"chapters/state.html":{"url":"chapters/state.html","title":"七、状态模式","keywords":"","body":"状态模式 环境 实现一个旅馆的住宿管理系统 房间的状态有三种：空闲，预定，入住 问题 背景：某对象发生变化时，其所能做的操作也随之变化。 应用程序的可维护性和重用性差。 代码的逻辑较复杂。 详解 state模式 允许对象在其内部状态改变的时候改变它的行为。 角色 环境类（Context）: 客户使用的对象类。维护一个State子类的实例，这个实例定义当前状态。 抽象状态类（State）: 定义一个接口以封装与Context的一个特定状态相关的行为。 具体状态类（ConcreteState）: 每一子类实现一个与Context的一个状态相关的行为。 图：staterole 实现 最常见的一种步骤 定义状态类接口，实现当前系统的真实状态实现此接口 定义Context类，具有状态的类，其中包含状态类接口的对象 当Context类执行某个接口的方法时，去调用真实状态类的实现方法 当Context类修改状态时，修改Context类的真实状态对象 © 2019 冯世祺. All rights reserved.本站访客数 人次"},"chapters/command.html":{"url":"chapters/command.html","title":"八、命令模式","keywords":"","body":"命令模式 环境 回想吃烧烤流程，多个客户，多个厨师。 客户想要吃5个烤鸡腿，10个烤羊肉串。 问题 背景：一个用户要对多个目标进行调用，而且目标对象的操作相似。 用户使用的复杂性加大，目标的执行效率会比较低。 增加目标的使用者的话，逻辑较复杂。 互动关系不能体现成类之间的直接调用，对象之间关系的耦合度大。 详解 command pattern 让行为的发送者和执行者完全解耦。 当用户发出命令后，无需关注谁来执行命令，有转发者来进行命令的调配和转发。 将命令的发出者和命令的执行者完全隔离开。 角色 Command：定义命令的接口，声明执行的方法。 ConcreteCommand：命令接口实现对象， 通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。 Receiver：接收者，真正执行命令的对象。 Invoker：传递者，要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。 Client：创建具体的命令对象，并且设置命令对象的接收者。组装命令对象和接收者，因为真正使用命令的客户端是从Invoker来触发执行。 客户端发出命令给传递者，传递者把命令传递给真正执行命令的执行者去执行操作。 命令模式有很多种实现形式，比较常见的一种是“客户下达命令-----传达者接收，并传递给执行者----执行者接收到命令，执行命令”。 图：commandstep 图：commanduml 实现 图：commandrealization © 2019 冯世祺. All rights reserved.本站访客数 人次"},"chapters/facade.html":{"url":"chapters/facade.html","title":"九、外观模式","keywords":"","body":"外观模式 环境 电脑的组成你了解么？ 你了解电脑的启动过程吗？ 请设计一个电脑类。其中包含电脑的开启和关闭方法。 背景 用户希望使用一个比较复杂的子系统。但是用户不希望跟子系统的复杂的模块交互，也不想了解复杂的子系统内部的结构，且子系统结构变化后，不需要改变用户的使用方式。 详解 Facade 为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 使客户尽量少的与子系统内部的组件打交道，尽量维护子系统的统一的接口。 使系统的用户和系统通过façade类解耦。当子系统改变时，只要保证façade类的接口不变，用户的使用方式就无需改变。 外观模式的实现一般采用：在子系统外部封装façade类的方式实现。 角色 目标类: 子系统类的合集。 外观类: 一个相对复杂的子系统类的外观类。 客户端类: 要使用子系统类中各个方法的用户类。 图：facaderole © 2019 冯世祺. All rights reserved.本站访客数 人次"},"chapters/proxy.html":{"url":"chapters/proxy.html","title":"十、代理模式","keywords":"","body":"代理模式 概念 为其他对象提供一种代理以控制对该对象的访问。 通过代理对象实现调用对象和被调用对象之间的解耦。当被调用对象改变时，只要保证代理对象的接口不变，调用对象的使用方式无需改变。 代理模式的实现一般采用：创建一个公开接口或抽象类，被代理类和代理类同时实现该接口，代理类的方法调用被代理类的方法来实现，这样调用类直接调用代理类就间接调用了被代理类。 代理模式应用 远程代理：为一个对象在不同的地址空间创建局部代表。这样来隐藏对象存在于不同地址空间的事实。 虚拟代理：需要创建开销很大的对象时，通过虚拟代理存放需要很长时间实例化的真实对象。 安全代理：用来控制真实对象访问时的权限。 智能指引：当调用真实对象时，代理会处理另外一些事情。 代理模式实现 扩展 代理是将目标对象的复杂性进行封装，通过代理来完成调用，针对客户端调用的目标类型完成接口定义，并且目标对象要实现这个接口，代理类也要实现这个接口。 某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。 客户端分辨不出代理对象与真实对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口。 © 2019 冯世祺. All rights reserved.本站访客数 人次"},"chapters/bridge.html":{"url":"chapters/bridge.html","title":"十一、桥接模式","keywords":"","body":"桥接模式 环境 现在我们要开发一个通用的日志记录工具 它既可以运行在.NET平台，也可以运行在Java平台上 它支持数据库记录和文本文件记录 详解 在软件系统中，应对“多维度的变化”，应将抽象部分与实现部分分离。 图：bridgedivide 把日志记录方式和不同平台上的实现分别当作两个独立的部分来对待，我们要做的工作就是把这两部分之间连接起来。Bridge使用了对象组合的方式。 图：bridgelogs 合成/聚合复用原则 合成（组合，Composition）和聚合（Aggregation）都是关联关系的特殊种类。 聚合表示一种弱的“拥有”关系**，A对象可以包含B对象，但B对象不是A对象的一部分。 合成表示一种强的“拥有”关系，体现了严格的整体和部分的关系，部分和整体的生命周期是一样的。 图：大雁和翅膀和雁群的关系 © 2019 冯世祺. All rights reserved.本站访客数 人次"},"chapters/iterator.html":{"url":"chapters/iterator.html","title":"十二、迭代器模式","keywords":"","body":"迭代器模式 环境 在软件构建过程中，集合对象内部结构常常变化各异。但对于这 些集合对象，我们希望在不暴露其内部结构的同时，可以让外部 客户端代码透明地访问其中包含的元素；同时这种“透明遍历” 也为“ 同一种算法在多种集合对象上进行操作”提供了可能。 应用场景 访问一个集合对象的内容，而无需暴露它的内部表示。 支持对集合对象的多种遍历。 为遍历不同的集合结构提供一个统一的接口(即, 支持多态迭代) 。 迭代器模式详解 概念 又叫做游标（Cursor）模式。 提供一种方法访问一集合对象中各个元素，而 又不需暴露该对象的内部细节。 迭代器模式是为容器（或者集合）而生。 四种角色 抽象集合：一个接口，规定了具体集合需要实现的操作。 具体集合：具体的集合按照一定的结构存储对象。具体集合应该有一个方法，该方法返回一个针对该集合的具体迭代器。 抽象迭代器：一个接口，规定了遍历具体集合的方法，比如 next()方法。 具体迭代器：实现了迭代器接口的类的实例。 设计类图 图：iteratorDesignClass 迭代器模式实现 图：iteratorImplement 扩展说明 优缺点 优点： 简化了遍历方式 可以提供多种遍历方式（正序遍历，倒序遍历……） 封装性良好 缺点： 对于比较简单的遍历（像数组或者有序列表），使 用迭代器方式遍历较为繁琐，大家可能都有感觉， 像ArrayList，我们宁可愿意使用for循环和get方法 来遍历集合 © 2019 冯世祺. All rights reserved.本站访客数 人次"},"chapters/filter.html":{"url":"chapters/filter.html","title":"十三、管道过滤器","keywords":"","body":"管道过滤器 体系结构的概念 软件体系结构 = 软件 的 体系结构 什么是体系结构 软件体系结构起源——建筑业 如何使用基本的建筑模块构造一座完整的建筑？ 包含两个因素： 基本的建筑模块 建筑模块之间的粘接关系 体系结构的共性 一组基本的构成元素—构件 这些要素之间的连接关系—连接件 这些要素连接之后形成的拓扑结构—物理分布 作用于这些要素或连接关系上的限制条件—约束 质量—性能 体系结构 = 构件 + 连接件 + 约束 体系结构的风格（分类） 经典SA风格 图：classicstyle 其他常用SA风格 图：otherstyle 异构（复合）SA风格 数据流风格 概念 数据从一个处理单元流入到另一个处理单元，每经过一个单元就做一次转换。 注意：数据流风格不是某个过程的数据流图，它描述的是系统体系结构级别的设计，体系结构风格是系统级的。 直观理解 图：处理：数据到达即被激活，无数据时不工作。 基本构件（Component） 基本构件：数据处理 构件接口：输入端口和输出端口 连接件（Connector） 连接件：数据流 拓扑结构（Topology） 任意拓扑结构的图 一般来说，数据的流向是无序的 我们主要关注近似线性的数据流 或在限度内的循环数据流 三种典型的数据流风格 管道/过滤器（Pipe-and-Filter） 数据流的转换作为单独的过程 批处理（Batch Sequential） 转换可以顺序地或并行地执行，数据加工逐项进行 过程控制（Process Control） © 2019 冯世祺. All rights reserved.本站访客数 人次"},"chapters/MVC.html":{"url":"chapters/MVC.html","title":"十四、MVC架构","keywords":"","body":"MVC架构 © 2019 冯世祺. All rights reserved.本站访客数 人次"},"chapters/SAstyle.html":{"url":"chapters/SAstyle.html","title":"十五、软件体系结构风格","keywords":"","body":"软件体系结构风格 © 2019 冯世祺. All rights reserved.本站访客数 人次"}}